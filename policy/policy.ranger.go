// Code generated by protoc-gen-rangerrpc version DO NOT EDIT.
// source: policy.proto

package policy

import (
	"context"
	"errors"
	"net/http"
	"net/url"
	"strings"

	ranger "go.mondoo.com/ranger-rpc"
	"go.mondoo.com/ranger-rpc/metadata"
	jsonpb "google.golang.org/protobuf/encoding/protojson"
	pb "google.golang.org/protobuf/proto"
)

// service interface definition

type PolicyHub interface {
	SetPolicyBundle(context.Context, *PolicyBundle) (*Empty, error)
	DeletePolicy(context.Context, *Mrn) (*Empty, error)
	ValidatePolicy(context.Context, *Policy) (*Empty, error)
	ValidatePolicyBundle(context.Context, *PolicyBundle) (*Empty, error)
	GetPolicy(context.Context, *Mrn) (*Policy, error)
	GetPolicyBundle(context.Context, *Mrn) (*PolicyBundle, error)
	GetPolicyFilters(context.Context, *Mrn) (*Mqueries, error)
	List(context.Context, *PolicySearchFilter) (*Policies, error)
}

// client implementation

type PolicyHubClient struct {
	ranger.Client
	httpclient ranger.HTTPClient
	prefix     string
}

func NewPolicyHubClient(addr string, client ranger.HTTPClient, plugins ...ranger.ClientPlugin) (*PolicyHubClient, error) {
	base, err := url.Parse(ranger.SanitizeUrl(addr))
	if err != nil {
		return nil, err
	}

	u, err := url.Parse("./PolicyHub")
	if err != nil {
		return nil, err
	}

	serviceClient := &PolicyHubClient{
		httpclient: client,
		prefix:     base.ResolveReference(u).String(),
	}
	serviceClient.AddPlugins(plugins...)
	return serviceClient, nil
}
func (c *PolicyHubClient) SetPolicyBundle(ctx context.Context, in *PolicyBundle) (*Empty, error) {
	out := new(Empty)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/SetPolicyBundle"}, ""), in, out)
	return out, err
}
func (c *PolicyHubClient) DeletePolicy(ctx context.Context, in *Mrn) (*Empty, error) {
	out := new(Empty)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/DeletePolicy"}, ""), in, out)
	return out, err
}
func (c *PolicyHubClient) ValidatePolicy(ctx context.Context, in *Policy) (*Empty, error) {
	out := new(Empty)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/ValidatePolicy"}, ""), in, out)
	return out, err
}
func (c *PolicyHubClient) ValidatePolicyBundle(ctx context.Context, in *PolicyBundle) (*Empty, error) {
	out := new(Empty)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/ValidatePolicyBundle"}, ""), in, out)
	return out, err
}
func (c *PolicyHubClient) GetPolicy(ctx context.Context, in *Mrn) (*Policy, error) {
	out := new(Policy)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/GetPolicy"}, ""), in, out)
	return out, err
}
func (c *PolicyHubClient) GetPolicyBundle(ctx context.Context, in *Mrn) (*PolicyBundle, error) {
	out := new(PolicyBundle)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/GetPolicyBundle"}, ""), in, out)
	return out, err
}
func (c *PolicyHubClient) GetPolicyFilters(ctx context.Context, in *Mrn) (*Mqueries, error) {
	out := new(Mqueries)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/GetPolicyFilters"}, ""), in, out)
	return out, err
}
func (c *PolicyHubClient) List(ctx context.Context, in *PolicySearchFilter) (*Policies, error) {
	out := new(Policies)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/List"}, ""), in, out)
	return out, err
}

// server implementation

type PolicyHubServerOption func(s *PolicyHubServer)

func WithUnknownFieldsForPolicyHubServer() PolicyHubServerOption {
	return func(s *PolicyHubServer) {
		s.allowUnknownFields = true
	}
}

func NewPolicyHubServer(handler PolicyHub, opts ...PolicyHubServerOption) http.Handler {
	srv := &PolicyHubServer{
		handler: handler,
	}

	for i := range opts {
		opts[i](srv)
	}

	service := ranger.Service{
		Name: "PolicyHub",
		Methods: map[string]ranger.Method{
			"SetPolicyBundle":      srv.SetPolicyBundle,
			"DeletePolicy":         srv.DeletePolicy,
			"ValidatePolicy":       srv.ValidatePolicy,
			"ValidatePolicyBundle": srv.ValidatePolicyBundle,
			"GetPolicy":            srv.GetPolicy,
			"GetPolicyBundle":      srv.GetPolicyBundle,
			"GetPolicyFilters":     srv.GetPolicyFilters,
			"List":                 srv.List,
		},
	}
	return ranger.NewRPCServer(&service)
}

type PolicyHubServer struct {
	handler            PolicyHub
	allowUnknownFields bool
}

func (p *PolicyHubServer) SetPolicyBundle(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req PolicyBundle
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.SetPolicyBundle(ctx, &req)
}
func (p *PolicyHubServer) DeletePolicy(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req Mrn
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.DeletePolicy(ctx, &req)
}
func (p *PolicyHubServer) ValidatePolicy(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req Policy
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.ValidatePolicy(ctx, &req)
}
func (p *PolicyHubServer) ValidatePolicyBundle(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req PolicyBundle
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.ValidatePolicyBundle(ctx, &req)
}
func (p *PolicyHubServer) GetPolicy(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req Mrn
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.GetPolicy(ctx, &req)
}
func (p *PolicyHubServer) GetPolicyBundle(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req Mrn
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.GetPolicyBundle(ctx, &req)
}
func (p *PolicyHubServer) GetPolicyFilters(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req Mrn
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.GetPolicyFilters(ctx, &req)
}
func (p *PolicyHubServer) List(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req PolicySearchFilter
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.List(ctx, &req)
}
